# Report processing and policy generation
In generation collected reports are processed and an minimal, according policy is created.

Unluckily violation reports generated by different browsers differ substancially, so having one processor for all types of clients would be difficult. It could be achieved by analysis of the reports or by storing the UAS of the reporter.

We instead choose to focus on violation reports generated by Google Chrome, as it is one of the most used desktop browsers and features plugins like postman useful in web application testing.

## Dependencies
The generator is written in Haskell, so you need `ghc` or another Haskellcompiler of your choice. Non-standard packets used are
 1. Data.JSON
 2. Text.URI
 3. Data.Aeson

These can be installed via `cabal-install`:

 1. `$ cabal update`
 2. `$ cabal install JSON`
 3. `$ cabal install URI`
 3. `$ cabal install Aeson`

In some cases a global installation (`-g` flag) might be necessary.

## Input
Input should be a file of CSP-Reports in normal JSON format, separated by a newline, so exactly one report per line. We chose this format over a proper JSON list as it makes continous collection easier.

`sampleReports.txt` is such a file, generated by `../collector/read.php` with reports sent by Google Chrome Version 51.0.2704.106 from a site containing
 1. a local video
 2. an image from twimg.com
 3. google maps with a local script and inline style

`sampleReports.csp` is the policy generated from these reports.

## Configuration
A `gen.conf` file is used for configuration. It should contain a JSON-Object with all necessary fields. So there is no dedicated commentary option for this file, a work around would be using unused fields for comments.

This is a not a solution I'm really happy with, we will look into changing that in the future.

Fields:
 1. `inpath` is the path to the input file
 1. `outpath` is the path of the file where the new policy should be written
 2. `self` is the address under which the client originally reached the server and it will be translated to `'self'` in the actual policy.
 3. `inline` is an array of sources that should allow `unsafe-inline`
 4. `eval` is an array of sources that should allow `unsafe-eval`

Theoretically `self` should be deducable from the reports, though we are not certain about the stability of this. If an illegal occurence of a keyword (inline, eval) occurs, the generation will fail.
